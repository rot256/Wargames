

# This file was *autogenerated* from the file doit.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_128 = Integer(128); _sage_const_7 = Integer(7); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16)
import struct

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt

from Crypto.Cipher import AES

F = GF(_sage_const_2 **_sage_const_128 , 'x', x**_sage_const_128  + x**_sage_const_7  + x**_sage_const_2  + x + _sage_const_1 , names=('x',)); (x,) = F._first_ngens(1)
G = PolynomialRing(F, names=('y',)); (y,) = G._first_ngens(1)

def bin(vs):
    '''
    Converts a list of bytes to a binary string
    '''

    o = ''
    for v in vs:
        o += '{:08b}'.format(ord(v))
    return o

def poly(bs):
    '''
    Constructs a polynomial in GF(2^128)[y]
    with the coefficients in bs
    '''

    p = _sage_const_0 
    for b in bs:
        p += b
        p *= y
    return p

def decode(v):
    '''
    Converts an AES block (128-bits)
    to a field element in GF(2^128)
    '''

    assert len(v) == _sage_const_16 
    v = int(bin(v)[::-_sage_const_1 ], _sage_const_2 )
    return F.fetch_int(v)

def encode(v):
    '''
    Converts an element from GF(2^128)
    to an AES block (128-bits)
    '''

    assert v in F
    v = '{:0128b}'.format(v.integer_representation())
    v = int(v[::-_sage_const_1 ], _sage_const_2 )
    return ('%032x' % v).decode('hex')


def make_mac(k, n, msg):
    assert len(msg) % _sage_const_16  == _sage_const_0 
    assert len(n) == _sage_const_16 

    blocks = [decode(msg[i:i+_sage_const_16 ]) for i in range(_sage_const_0 , len(msg), _sage_const_16 )]

    aes = AES.new(k, AES.MODE_ECB)

    H = decode(aes.encrypt(_sage_const_16  * '\x00'))
    P = decode(aes.encrypt(n))

    E = ([P] + blocks)[::-_sage_const_1 ]
    f = product([b * y**i for (i, b) in enumerate(E)])
    t = f(H)

    ct = msg + encode(t)

    # sanity check
    cipher = AESGCM(key)
    plaintext = cipher.decrypt(n, ct, associated_data=None)


make_mac(_sage_const_16  * b'\x13', _sage_const_16  * b'\x01', _sage_const_16  * b'\x00')





