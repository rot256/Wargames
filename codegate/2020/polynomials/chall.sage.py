

# This file was *autogenerated* from the file chall.sage
from sage.all_cmdline import *   # import sage library

_sage_const_9 = Integer(9); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_16 = Integer(16); _sage_const_8 = Integer(8); _sage_const_55 = Integer(55); _sage_const_4027 = Integer(4027)#!/usr/bin/env sage
from sage.misc.banner import version_dict
from Crypto.Util.number import long_to_bytes as l2b
from Crypto.Util.number import bytes_to_long as b2l
from Crypto.Util.Padding import pad
from Crypto.Cipher import AES
from os import urandom

assert version_dict()["major"] >= _sage_const_9 


class Chall:
    def __init__(self, N, p, q):
        self.N, self.p, self.q = N, p, q
        self.R = PolynomialRing(Integers(q), "x")
        self.x = self.R.gen()
        print('x:', self.x)
        self.S = self.R.quotient(self.x ** N - _sage_const_1 , "x")
        self.h, self.f = None, None

    def random(self):
        return self.S([randint(-_sage_const_1 , _sage_const_1 ) for _ in range(self.N)])

    def keygen(self):
        while True:
            self.F = self.random()
            self.f = self.p * self.F + _sage_const_1 
            try:
                self.z = self.f ** -_sage_const_1 
            except:
                continue
            break
        while True:
            self.g = self.random()
            try:
                self.g ** -_sage_const_1 
            except:
                continue
            break
        self.h = self.p * self.z * self.g

    def getPublicKey(self):
        return list(self.h)

    def getPrivateKey(self):
        return list(self.f)

    def encrypt(self, m):
        m_encoded = self.encode(b2l(m))
        e = self.random() * self.h + self.S(m_encoded)
        return list(e)

    def decrypt(self, e, privkey):
        e, privkey = self.S(e), self.S(privkey)
        temp = map(Integer, list(privkey * e))
        temp = [t - self.q if t > self.q // _sage_const_2  else t for t in temp]
        temp = [t % self.p for t in temp]
        pt_encoded = [t - self.p if t > self.p // _sage_const_2  else t for t in temp]
        pt = l2b(self.decode(pt_encoded))
        return pt

    def encode(self, value):
        assert _sage_const_0  <= value < _sage_const_3  ** self.N
        out = []
        for _ in range(self.N):
            out.append(value % _sage_const_3  - _sage_const_1 )
            value -= value % _sage_const_3 
            value /= _sage_const_3 
        return out

    def decode(self, value):
        out = sum([(value[i] + _sage_const_1 ) * _sage_const_3  ** i for i in range(len(value))])
        return out

    def count(self, row):
        p = sum([e == _sage_const_1  for e in row])
        n = sum([e == self.q - _sage_const_1  for e in row])
        return p, len(row) - p - n, n


def wrapper(N, p, q, pt):
    chall = Chall(N, p, q)
    chall.keygen()
    print(chall.getPublicKey())
    print(chall.encrypt(pt))
    print(chall.count(list((chall.F))))

if __name__ == "__main__":
    key = urandom(_sage_const_16 )
    cipher = AES.new(key, AES.MODE_ECB)
    flag = pad(open("flag.txt", "rb").read(), _sage_const_16 )
    enc_flag = b2l(cipher.encrypt(flag))
    print(enc_flag)

    key1, key2 = key[:_sage_const_8 ], key[_sage_const_8 :]

    #wrapper(55, 3, 4027, key1)
    #wrapper(60, 3, 1499, key2)
    wrapper(_sage_const_55 , _sage_const_3 , _sage_const_4027 , b'A'*_sage_const_8 )

